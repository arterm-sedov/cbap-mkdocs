---
title:
kbId:
tags:
    - интеграции
    - интеграция
hide: tags
---

# Интеграции. С чего начать?

Общая статья для понимания, как подступиться к интеграции, с чего начать.

1. Определить, какая система в какой момент передает данные.
2. Какие данные? 
3. Как сформировать запрос (рекомендации) если много данных, и если всего один параметр (если есть различия).
4. Упомянуть, что в продукте есть API.
5. Как протестировать сформированный запрос.
6. Настройка интеграции в системе.

## Определения

**Интеграции** — набор процессов для объединения **{{ productName }}** с другими внешними системами и обмена данными с ними.

**{{ productName }}** поддерживает стандарты REST API и основные методы:

    - GET – чтение данных;
    - POST – создание данных;
    - PUT – изменение или обновление данных;
    - DELETE – удаление данных.

## Типы API в {{ productName }}

Платформа поддерживает запросы из внешних систем через интерфейсы **REST API** трёх типов:

- [Solution API][api_solution]
- [System Core API][api_system_core]
- [Web API][api_web]

Чтобы посмотреть доступные методы, введите URL в своём браузере:

```
http://your-host/docs
```

Здесь `your-host` — адрес сервера **{{ productName }}**.

См. также _«[Введение в API][api_intro]»_.

## Общий порядок настройки

Чтобы настроить интеграцию, выполните следующие шаги:

1. Настройте интеграцию в приложении.
2. Создайте и настройте подключение.
3. Создайте и настройте пути передачи данных.
4. Настройте сценарий.

## Настройка интеграции

1. Откройте страницу страницу «**Администрирование**» приложения.
2. Выберите пункт «**Интеграции**» <i class=" fal  fa-sync-alt  title-settings-icon"></i>.
3. 

# API системы

Comindware Application Platform это RESTful API платформа, которая может подключаться к другим веб-платформам для взаимодействия с ними, также платформа позволяет подключение к себе для выгрузки данных в другие системы. Например, можно связаться с Microsoft Power Bi.

Что такое API? API (Application programming interface) это набор методов, с помощью которых, один продукт может взаимодействовать с другими. Платформа comindware предлагает несколько методов взаимодействия с платформой: GET, POST, DELETE, PUT. Ниже будет представлены те услуги, которые вы можете получить при использовании данных методов: Вы можете выполнить следующие запросы к платформе при использовании API:

1.       GET – получение данных

2.       POST – создание новых данных

3.       PUT – обновление данных

4.       DELETE – удаление данных

# Кто передает данные?

В самом начале работы с интеграциями нужно определить роли систем в данной интеграции. Речь идет о том, кто из систем является «передатчиком», а кто является «приемником» данных. Под передатчиком подразумевается система, которая передает данные, а под приемником та система, которая данные будет принимать.

Это нужно обязательно знать, потому что при настройке новой интеграции в Comindware application platfrom нужно будет выбирать тип интеграции: «Импорт» или «Экспорт».

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

# Какие данные?

Во время интеграции с comindware application platform существует возможность выгружать данные из существующих шаблон записи. Во время такой загрузки будут загружены все записи выбранного шаблона записи, а также соответствующие значения атрибутов ШЗ для данной записи.

# Формат передаваемых данных

Если система выступает в роли передатчика данных, то она может передавать существующие в ней данные в формате XML или JSON. Формат передаваемых данных можно выбрать на странице API платформы.

Если же система выступает в роли приемника данных, то запросы к API выполняются в формате JSON.

# Как сформировать запрос (рекомендации), если много данных и если один (есть ли различия)

Для формирования запроса вам нужно перейти Comindware Business Application Platform API путем написания в поисковой строке браузера после вашего доменного имени /docs.

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

Далее вам нужно выбрать Solution Api и в списке шаблонов записи выбрать вас интересующий. Стоить заметить, что все шаблоны здесь представлены по их системным именам, которые были прописаны либо автоматически, либо вручную, при создании шаблона записи. Теперь вы должны выбрать тип запроса, который будет выполнен к данному шаблону записи, выбирать можно только те запросы, которые не стоят вместе с префиксом id.

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

Далее вам нужно будет нажать на кнопку «Try it out!». После нажатия данной кнопки вам станет доступно следующее окно:

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

_Curl__- в_ данном поле представлен запрос curl, который вы можете написать в командной строке, если у вас установлен curl;

_Request_ _URL__-_ в данном поле представлен URL, который вы можете скопировать и вставить в поисковую строку браузера, либо в excel, либо в power bi.

# Как протестировать сформированный запрос

Протестировать запросы вы можете с помощью программы Postman.

# Настройка интеграции в системе

Если вы напишите в адресной строке вашего браузера после доменного имени вашего приложения «/docs», то вы попадете на страницу «Comindware Business Application Platform API».

Также вы можете сделать интеграцию какой-то системы в вашу систему «напрямую». Для этого вам нужно зайти в пункт бокового меню «Бизнес-приложения» и в списке бизнес-приложений выбрать то, где вы хотите сделать интеграцию.

В окне «Администрирование» вам нужно будет выбрать пункт «Интеграции».

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

При нажатии этой кнопки вы перейдете на страницу интеграций, где вы сможете увидеть уже существующие, создать новые, а ещё и просмотреть журнал с работой существующих интеграций.

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

Для создания новой интеграции вам нужно нажать «Создать», после нажатия которой у вас откроется окно создания и настройки новой интеграции:

![](file:///C:/Users/emar/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

_Название_- здесь вы должны дать название для вашей новой интеграции;

_Канал_ _OData__-_ в этом поле вы должны выбирать канал связи для связи с нужной вам системой;

_Тип-_ Вы должны выбрать тип вашей интеграции. Вам предстоит выбрать из двух значений: «Импорт» и «Экспорт». Здесь вы выбираете, какая система будет являться «приемником», а какая «передатчиком»;

_Запуска по расписанию-_ Если вы оставите в поле значение «Вручную», то взаимодействие систем будет происходить только по инициативе пользователя. Если же выбрать значение «По расписанию», то вы сможете настроить запуск интеграции автоматически.



**Документация по настройке интеграций с использованием кастомных адаптеров**

Оглавление

[1.     Создание адаптера на основе vsdl 3](#_Toc173744313)

[2.     Маппинг. 4](#_Toc173744314)

[3.     Настройка и проработка подключений. 5](#_Toc173744315)

[4.     Настройка триггера. 6](#_Toc173744316)

[5.     Тестирование. 7](#_Toc173744317)

[5.1. Тестирование принятия. 7](#_Toc173744318)

[5.2. Тестирование отправки. 15](#_Toc173744319)

[5.3. Основные проблемы, которые могут возникнуть и их решение. 16](#_Toc173744320)

# 1.                 Создание адаптера на основе vsdl

# 1.1.          Устройство адаптера

Адаптер состоит из следующих блоков:[[EM1]](#_msocom_1) 

1)                 Блок сериализации и десериализации данных.

2)                 Блок описания модели данных и преобразование данной модели во внутреннюю модель адаптера. Структура модели данных должна совпадать с внутренней моделью адаптера, но может отличаться по названием полей.

3)                 Блок endpoint или методов адаптера. Данный блок необходим для распределения запросов между разными моделями данных, хранящихся в адаптере. В одном адаптере может быть описано более 1 модели (клиенты\договоры\продукты).

4)                 Блок служб, который отвечает за поднятие kestrel на порту, отправки сообщений, таймаутов и тд.

# 1.2.  Процесс создания адаптера

1)    Заказчик предоставляет структуру данных в стандартизированном формате или в виде таблицы.

2)    На основе структуры модели данных, описанной в xsd или vsdl, генерируется классовая структура модели данных адаптера. Для этого используются парсеры и автогенераторы, например [https://json2csharp.com/code-converters/xml-to-csharp](https://json2csharp.com/code-converters/xml-to-csharp).

3)    Программист, разрабатывающий адаптер, может модифицировать некоторые параметры модели данных, например изменять названия полей, делать преобразования данных (конвертировать строки в число) или даже изменять модель данных, которую он передает в свою систему (добавлять верхнеуровневые объекты и тд).

Кастомные адаптеры имеют целый ряд преимуществ:

·        быстрота реализации;

·        возможность обрабатывать и преобразовывать данные на уровне адаптера, видоизменять структуру данных;

·        слитые адаптеры;

·        отказоустойчивость.

Основным недостатком адаптеров является большее количество шагов для обновления, в случае внесения изменений.

  

# 2.                 Маппинг.

1)    Заказчик предоставляет пример запроса:  
{

    "EntitytItems": [{

            "UniqueObjectCode": "8092374509234785",

            "Contract": "НТ-132-МН-493",

            "Status": 1,

            "UniqueCustomerCode": "8999000221",

            "StartDate": "2024-07-27T12:00:00+03:00",

            "EndDate": "2024-07-28T12:00:00+03:00",

            "Currency": "RUB",

            "CodeOrganization": "8829",

        }

    ]

}

Для нас данный запрос не имеет никакой смысловой нагрузки. Не понятно, что означают эти поля, для чего они нужны и вообще нужны ли?  
Но, зная, что это за интеграция, и зная, какая сущность передается, мы можем понять, с чем сопоставлять данные поля.

К примеру, заказчик объяснил нам, что в запросе содержится информация о Договоре.

2)    Далее необходимо узнать легенду каждого необходимого для нас поля. Заказчик сообщает, что ему необходимы следующие поля: EntitytItems, так как в этом массиве объекта хранятся все остальные поля, UniqueObjectCode, Contract, Status, UniqueCustomerCode, StartDate, EndDate, CodeOrganization, а Currency не нужен.

|   |   |   |
|---|---|---|
|Название поля|Тип|Описание|
|UniqueObjectCode|String|Код договора|
|Contract|String|Название контракта|
|Status|Int|Код статуса|
|UniqueCustomerCode|String|Код юрлица|
|StartDate|Date|Дата заключения|
|EndDate|Date|Дата завершения|
|CodeOrganization|String|Код организации|

3)    Для корректной отработки запросов требуется запросить необходимые справочники (на практике они состоят из названий и кодов) и создать их в нашей системе.

4)    После необходимо подготовить шаблон ответных [[EM2]](#_msocom_2) данных нашего приложения или системы, например шаблон записи «Договоры» со следующими атрибутами:  
  

|   |   |   |   |
|---|---|---|---|
|Название поля|Системное имя|Тип|Описание|
|Внешний id|Contract_ExternalId|Текст|Код договора|
|Заголовок|Contract_Title|Текст|Название контракта|
|Статус|Contract_Status|Запись|Статус|
|Юрлицо|Contract_PartyInvolved_Legalentity|Запись|Юрлицо|
|Дата регистрации|Contract_RegistrationDate|Дата и время|Дата Регистрации|
|Дата окончания|Contract_EndDate|Дата и время|Дата завершения|
|Организация|Contract_PartyInvolved_Organisation|Запись|Организация|

  
  

 

Подготовка таблицы с набором полей 1 системы

- Подготовка таблицы с набором полей 2 системы

- Слияние и в случае необходимости, доработка системы (Создание необходимых новых шз, атрибутов и тд )[[EM3]](#_msocom_3) 

  

# 3.                 Настройка и проработка подключений

**3.1 Настройка подключения для отправки запросов**

Для начала нужно создать подключение:

1.     Переходим в «Администрирование»→«Подключения».

2.     Нажимаем кнопку «Создать»→«Подключения REST и OData»→«Отправка HTTP-запросов».

![](file:///D:/Temp/msohtmlclip1/01/clip_image002.jpg)

3.     Указываем следующие данные:

·                    Системное имя

·                    Описание

·                    Запись в файловые журналы: Полные сведения об обработке сообщения

·                    URI

·                    Так как запрос без аутентификации, оставляем остальные поля пустыми.

Настроим путь передачи данных:

1.     Переходим «Администрирование»→Пути передачи данных».

2.     Нажимаем кнопку «Создать»→«Подключения REST и OData»→«Отправка HTTP-запросов».

![](file:///D:/Temp/msohtmlclip1/01/clip_image004.jpg)

3.                  Настраиваем основные свойства:

·                    Выбираем ранее настроенное подключение.

·                    Указываем системное имя.

·                    Указываем описание пути передачи данных.

4.     Настриваем «Атрибуты сообщений»:

·        Запрос оставляем пустым, так как наш URI уже содержит в себе атрибуты для передачи.

![](file:///D:/Temp/msohtmlclip1/01/clip_image006.png)

·        В ответе нам необходимо получить код статуса запроса, как при ответе с ошибкой, так и при корректном запросе. Получаем тип токена и сам токен.

![](file:///D:/Temp/msohtmlclip1/01/clip_image008.png)

5.                  Настриваем «Интеграцию»:

·                    Метод запроса – POST

·                    Шаблон пути запроса – здесь указывается переменная часть запроса.  
Если у нас есть несколько запросов, но один запрашивает, другой отправляет туда же, а третий удаляет, то мы можем создать одно подключение и несколько путей передачи данных, с разными наборами настроек.

·                    Атрибуты для сериализации в тело запроса – указываются атрибуты из таблицы «Запрос», которые находятся на верхнем уровне (сверните атрибуты, если есть вложенность и все, что будут видны), они должны указываться в данном поле, через запятую и без пробелов (также важны заглавные или строчные буквы).

·                    Укажите атрибуты для десериализации ответа без ошибки – здесь в хороших условиях просто указывается ‘$’, если совпадают атрибуты JSON и настроенные «Атрибуты сообщений». Если атрибуты отличаются, то можно воспользоваться JPath для соотношения атрибутов.

·                    Укажите атрибуты для десериализации ответа с ошибкой.

![](file:///D:/Temp/msohtmlclip1/01/clip_image010.png)

![](file:///D:/Temp/msohtmlclip1/01/clip_image012.png)

**3.2 Настройка подключения для получения запросов**

Для начала нужно создать подключение:

1.     Переходим в «Администрирование»→«Подключения».

2.     Нажимаем кнопку «Создать»→«Подключения REST и OData»→«Получение HTTP-запросов».

3.     Указываем следующие данные:

·                    Системное имя

·                    Описание

·                    Запись в файловые журналы: Полные сведения об обработке сообщения

·                    URI

·                    Формат данных: JSON

Настроим путь передачи данных:

1.     Переходим «Администрирование»→Пути передачи данных».

2.     Нажимаем кнопку «Создать»→«Подключения REST и OData»→«Получение HTTP-запросов».

3.     Настраиваем основные свойства:

·                    Выбираем ранее настроенное подключение.

·                    Указываем системное имя.

·                    Указываем описание пути передачи данных.

4.     Настриваем «Атрибуты сообщений»:

·        Запрос.[[EM4]](#_msocom_4) 

·        Ответ.[[EM5]](#_msocom_5) 

5.                  Настриваем «Интеграцию»:

·                    Указываем путь URI

·                    Указываем атрибуты для десериализации данных

·                    Указываем[[EM6]](#_msocom_6) 

  

# 4.                 Настройка сценария.

Сценарий [[EM7]](#_msocom_7) для получения данных выглядит следующим образом:

![](file:///D:/Temp/msohtmlclip1/01/clip_image014.png)

Стартовым событием является получение сообщения, в котором указана переменная. На скриншоте данная переменная названа var:

![](file:///D:/Temp/msohtmlclip1/01/clip_image016.png)

В данной переменной содержатся все данные, которые нам приходят.

Проверка на уникальное значение.

- Формирование ключей, преобразовывание типов данных ( По необходимости ), написание формул и создание связных сущностей.

- Обновление данных.

- Дозаполнение сущностей в случае отсутствия. У договора нет клиента, записываем в тех атрибут. При создании клиента ищем договор у которого был не найден данный клиент.

- Транзакционная сущность. Формирование записей о полученных или отправленных запросах

- Когда использовать триггер, когда процесс.

- Приемущества триггера и процесса.

  

# 5.                 Тестирование.

Тестирование бывает 2 видов:

·        тестирование отправки;

·        тестирование принятия.

ВНИМАНИЕ!

Перед тестированием следует обязательно проверить, включены ли подключения и пути передачи данных,  которые указаны в стартовом событии.  
  

# 5.1. Тестирование принятия.  
  

После отправки данных в нашу систему необходимо выполнить следующие шаги.

1)                 Открываем в администрировании Журналы событий→вкладка «Трассировка событий» и ставим фильтр по событию «Получен запрос». Сравниваем дату с текущим временем. Если будут строчки с вашим сценарием и будет указан шаблон записи «Договоры», значит, запрос получен.

Запрос не будет получен, если не работает ElasticSearch.

2)                 Переходим в Администрирование→Подключения и выбираем подключение, указанное в стартовом событии. Чтобы получить журнал событий, нажимаем кнопку «Скачать журнал».

  
![](file:///D:/Temp/msohtmlclip1/01/clip_image018.png)

3)    В скачанном архиве открываем файл без тега error  и спускаемся в самый конец файла.

![](file:///D:/Temp/msohtmlclip1/01/clip_image020.png)

4)    Ищем строку после тега Result request.

![](file:///D:/Temp/msohtmlclip1/01/clip_image022.png)

5)                 Копируем данную строку, вставляем на сайте [https://jsonlint.com/](https://jsonlint.com/) и нажимаем кнопку «Validate Json».

![](file:///D:/Temp/msohtmlclip1/01/clip_image024.png)

Получаем удобочитаемую структуру наших данных:

![](file:///D:/Temp/msohtmlclip1/01/clip_image026.png)

Данную структуру можно скопировать себе отдельно в блокнот или смотреть через сайт.

6)                 Так как сценарий создает запись в договорах, необходимо открыть шаблон «Договоры» и найти новый экземпляр.

В случае если он не создался, дело может быть как в запросе, так и в выключенных подключениях и путях передачи данных. Перепроверяем стартовое событие и указанные там подключения. Если все выглядит правильно, обращаемся ко мне. Нужно будет отправить запрос заново.

7)                 Открываем созданную запись и открываем действие «Изменить значения атрибутов»:

![](file:///D:/Temp/msohtmlclip1/01/clip_image028.png)

![](file:///D:/Temp/msohtmlclip1/01/clip_image030.png)

Возможно, в журнале изменений отобразятся атрибуты, которые изменились, однако информация в нем может быть неточной. Например, атрибуты, которые являются числом, в журнале будут указаны измененными, но в самой записи их поля будут пустые. Такие атрибуты нужно выписывать и узнавать, какие типы данных они содержат.

К примеру, «Сумма без НДС» в запросе приходит как строка, в журнале изменений отображается, что атрибут заполнен, но на деле он хранил пустое значение. В данном случае, в триггере необходимо обернуть переменную в функцию DECIMAL(), которая конвертирует строку в число.

![](file:///D:/Temp/msohtmlclip1/01/clip_image032.png)

8)                 После того как будет получен список атрибутов, которые не заполнились, открываем образец запроса, который был получен в п.5.

9)                 Сравниваем, какие данные есть в запросе из тех, которые не проставились, и выписываем их. Если в запросе не оказалось данных, которые прописываются, их нужно выписать отдельно для дополнения запроса и полной отладки триггера.

10)            Отладка атрибута типа запись требует дополнительных шагов:

·        Проверяем, какой код указан в запросе.

·        Заходим в шз «Договоры» и переходим в справочник, на который ссылается атрибут.

·        Пытаемся найти в данном справочнике полученный код.

·        Если такого кода нет или он другой формы, выписываем пример существующего кода или записываем, что он отсутствует, для дальнейшего запроса актуального справочника от заказчика. Также выписываем любой код, который можно подставить в запрос, для тестирования работы сценария.

11)            В случае, если код есть и в справочнике, и в запросе, но он не проставился при добавлении записи, перепроверяем формулу в сценарии.

Возможные проблемы работы сценария, выявленные на данный момент:

·                    Неправильно написана формула в сценарии;

·                    Отсутствие данных в запросе;

·                    Неправильно обозначено поле в адаптере (узнать достаточно проблематично);

·                    Отсутствие кода в справочнике;

·                    Неправильное заполнение данных (в поле число пытаемся записать строку);

·                    Неправильный маппинг;

·                    Неправильная структура сценария;

·                    Неправильные условия в сценарии;

·                    Неправильное сопоставление названий полей с атрибутами, в случае если в адаптере название полей не совпадает с названиями в XML;

·                    Черная магия (любой лаг).

  

# 5.2. Тестирование отправки

Первичное тестирование заключается в сравнении данных которые мы пытаемся отправить и примером запроса.

1)    Переходим в Администрирование→Подключения и выбираем подключение, указанное в стартовом событии. Чтобы получить журнал событий, нажимаем кнопку «Скачать журнал».

  
![](file:///D:/Temp/msohtmlclip1/01/clip_image033.png)

2)    В скачанном архиве открываем файл без тега error  и спускаемся в самый конец файла.

![](file:///D:/Temp/msohtmlclip1/01/clip_image034.png)

3)    Ищем строку после тега Result request.

![](file:///D:/Temp/msohtmlclip1/01/clip_image035.png)

4)    Копируем данную строку, вставляем на сайте [https://jsonlint.com/](https://jsonlint.com/) и нажимаем кнопку «Validate Json».

![](file:///D:/Temp/msohtmlclip1/01/clip_image036.png)

Получаем удобочитаемую структуру наших данных:

![](file:///D:/Temp/msohtmlclip1/01/clip_image037.png)

5)    Данную структуру можно скопировать себе отдельно в блокнот или смотреть через сайт.

6)     

Скачиваем логи как в пункте 2 и сравниваем запрос с примером. Сопоставляем наши данные и которые в примере. В случае подозрительных значений уточняем либо мапинг либо формулы в триггере.

Вопросы или ситуации не описанные в данной документации будут дополнятся в документ после уточнения причины данного поведения.

  

# 5.3.  Основные проблемы, которые могут возникнуть и их решение

1)                 Отключение клиентов или других интеграций. Заходим в пути передачи данных и выключаем конкретный путь. Ориентируемся по таблице Настройки всех интеграций[[EM8]](#_msocom_8) . ![](file:///D:/Temp/msohtmlclip1/01/clip_image039.png) 

2)                 Проверка интеграций после перезагрузки\обновления: Открываем подключения и ожидаем загрузки, если в колонке «Тип» есть пустые значения, значит они сломались. Пишем Гришину, что отвалились линки у подключений на адаптеры.

![](file:///D:/Temp/msohtmlclip1/01/clip_image041.png)

3)                 Проверка «Не пришел клиент»: смотрим журнал подключения, есть ли там данный клиент, ищем поиском его внешний id. Если такого нет, то просим отправить еще раз. Еще раз проверяем. Если он есть, но в транзакциях его нет, проверяем какой объем интеграций заходит, если они идут без конца, значит, он где-то в очереди. Иначе отправляем его сами в систему, как я объяснял.

4)                 Заливкой новых адаптеров лучше пусть занимается Максим, https://t.me/Napiform_Goose . Если срочно нужно, пишешь ему, он заливает. Предварительно тебе нужно во всех действиях сценария поставить заглушки. Одно подключение = 1 адаптер. Идем по табличке в каждое действие и меняем подключение и путь на заглушку. Далее удаляем пути и подключения по списку. Маякуем о том, что все готово для перезаливу адаптеров, Макс заливает, создаем подключение и необходимые пути и меняем в триггерах подключения и пути. Тестируем либо сами, либо при помощи Макса (отправляем запросы в CRM).

---

 [[EM1]](#_msoanchor_1)Можно добавить определение, что такое vsdl, зачем он нужен и т.п.

 [[EM2]](#_msoanchor_2)Это же шз, на самом деле?

 [[EM3]](#_msoanchor_3)Это, наверное, можно уже удалить 😊

 [[EM4]](#_msoanchor_4)Надо описать

 [[EM5]](#_msoanchor_5)Надо описать

 [[EM6]](#_msoanchor_6)Что еще нужно указать?

 [[EM7]](#_msoanchor_7)Надо дальше расписать, какие действия что делают.

 [[EM8]](#_msoanchor_8)Оно точно так называется? Не просто интеграции?